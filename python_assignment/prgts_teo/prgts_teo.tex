
\documentclass{article}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=red]{hyperref}
\usepackage[most, listings]{tcolorbox}
\usepackage{verbatimbox}
\usepackage{alltt}
\usepackage{fancyvrb}
\usepackage{newverbs}
\newverbcommand{\rverb}{\color{red}}{}
\newverbcommand{\bverb}{\color{blue}}{}

\begin{document}

\begin{center}
  \LARGE{Preguntas teóricas}    \\
\end{center}

\vspace{0.5cm}

\begin{enumerate}
\item ¿Qué es un condicional?
\par\hspace{5pt} Un condicional (\verb|if|) es un tipo de proposición que permite ejecutar un ``bloque de código'' sujeto a una determinada condición. Dicho tipo de proposiciones posee la siguiente estructura formal: si la condidición es evaluada \verb|True| entonces se ejecuta el ``bloque de còdigo'', en caso que sea \verb|False|, se ignorará el bloque (es decir, no se imprimirá nada en el terminal).  
\begin{tcolorbox}
\begin{alltt}
precio = 50
\textcolor{blue}{if} precio < 70:
    \textcolor{red}{print}("precio es menor que 70")
\end{alltt}        
\end{tcolorbox}
\par\hspace{5pt} Ahora bien, \emph{no} es necesario colocar una sola condición en un \emph{script}; se pueden colocar 2 o más condiciones, buscando abarcar los distintos escenarios posibles. Para ello se utliza la clausula \verb|elif|, una síntesis entre las clausulas \verb|else| e \verb|if|.
\begin{tcolorbox}
\begin{alltt}
precio = 70
\textcolor{blue}{if} precio < 70:
    \textcolor{red}{print}("precio es menor que 70")
\textcolor{blue}{elif} precio == 70:
    \textcolor{red}{print}("precio es igual que 70")
\end{alltt}        
\end{tcolorbox}
\par\hspace{5pt} Junto con una proposición \verb|if| se puede colocar también una condición \verb|else| que permita, a su vez, definir un ``bloque de código'' ejecutable en caso que la condición \verb|if| sea evaluada como \verb|False|.
\begin{tcolorbox}
  \begin{alltt}
  precio = 70
  \textcolor{blue}{if} precio == 70:
    \textcolor{red}{print}("precio es igual a  70")
  \textcolor{blue}{else}:
    \textcolor{red}{print}("precio es distinto que 70")
  \end{alltt}        
  \end{tcolorbox}
\vspace{0.5cm}

\item ¿Cuáles son los diferentes tipos de bucles en Python? ¿Por qué son útiles?
\par \hspace{5pt} En \emph{python} existen 2 grandes tipos de bucles o \emph{loops}: \emph{for} y \emph{while}. A veces se menciona un tercer tipo de bucle, \emph{nested loop}\footnote{Véase, por ejemplo, \url{https://www.codecademy.com/resources/docs/python/loops}.}, pero si se lo entiende como un bucle ``dentro'' de otro, no parece constituir un bucle tan básico o fundamental como los otros dos.
\begin{itemize}
\item Bucle \emph{while}
\par \hspace{5pt} Dicho tipo de bucle se caracteriza por ejecutar un código una y otra vez, hasta que la(s) condicion(es) especificada(s) sea(n) falsa(s). A continuación analizaremos algunos ejemplos para aclarar un poco más dicha caracterización.
\begin{tcolorbox}
\begin{alltt}
a = \textcolor{purple}{1}
while a < \textcolor{purple}{10}:
  print(\textcolor{red}{"¡Hola mundo!"})
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} Si ejecutamos este código, veremos que el programa imprimirá \emph{infinítamente} el mensaje que aparece ahí. ¿Por qué infinitamente? Básicamente, porque dicho código posee dos \emph{proposiciones} que de alguna manera no se ``cruzan'' nunca. Por un lado, una primera proposición que define el valor inicial de \verb|a| como una constante e igual a \verb|1|. Y por el otro lado, una proposición \emph{condicional} que plantea que, mientras \verb|a| sea menor que \verb|10|, se imprima el mensaje que aparece entre comillas.  Dado que \verb|a| es definida como una constante o una variable estática, es decir, que no varía su valor luego de cada bucle, \verb|a| nunca será mayor que \verb|10|, haciendo que el valor de verdad de dicha condición sea siempre verdadera.
\par \hspace{5pt} Para que no suceda lo anterior, a saber, una iteración que tienda al infinito\footnote{Claramente un \emph{script} o código que ``dé vueltas en redondo'' presenta un error.}, es necesario que el bucle cuente con lo que se llama un \emph{contador}. Aquello permite que la variable se comporte de manera dinámica, para decirlo de alguna manera, aumentando o disminuyendo después de cada bucle.
\begin{tcolorbox}
\begin{alltt}
a = \textcolor{purple}{1}
while a < \textcolor{purple}{10}:
    print(\textcolor{red}{"¡Hola mundo!"})
    a = a + \textcolor{purple}{1}
\end{alltt}        
\end{tcolorbox}
\par \hspace{0.5cm} Al ejecutar dicho código, veremos que la iteración se lleva a cabo en este caso solo en nueve ocasiones. ¿Por qué? Porque al incorporar un \emph{contador} en el código, en cada \emph{ciclo} del bucle la variable \verb|a| aumentará en uno, hasta el punto en que \verb|a| sea igual a \verb|10|, haciendo que la condición formulada sea falsa y, de ese modo, finalice el bucle.
\item Bucle \emph{for}
\par \hspace{5pt} Un bucle tipo \emph{for} se utiliza, a su vez, para iterar en general sobre una sequencia: lista, tuple, dictionario, conjunto y/o \emph{string}. Veámos a continuación algunos ejemplos.
\begin{tcolorbox}
\begin{alltt}
frutas = ["manzanas", "peras", "fresas"]
\textcolor{blue}{for} x \textcolor{blue}{in} frutas:
    \textcolor{blue}{print}(x)
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} Si ejecutamos dicho bucle en el terminal, veremos que se imprime hacia abajo el nombre de cada fruta incluida en el lista.
\begin{tcolorbox}
\begin{alltt}
manzanas
peras
fresas
\end{alltt}        
\end{tcolorbox}
\vspace{0.5cm}
\par \hspace{5pt} Algo parecido resulta cuando intentamos realizar un bucle sobre un determinado \emph{string}.
\begin{tcolorbox}
\begin{alltt}
\textcolor{blue}{for} x \textcolor{blue}{in} "frutas":
    \textcolor{blue}{print}(x)
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} En este caso, si ejecutamos el bucle, veremos que se imprime en el terminal ``hacia abajo'' cada letra del término \emph{frutas}.
\begin{tcolorbox}
\begin{alltt}
f
r
u
t
a
s
\end{alltt}        
\end{tcolorbox}
\vspace{0.25cm}
\end{itemize}
\par \hspace{5pt} Es importante señalar que en ambos tipos de bucles (\emph{for} y \emph{while}) es posible parar o ``quebrar'' la iteración antes que ella finalece utilizando la siguiente expresión: \rverb|break|.
\begin{tcolorbox}
\begin{alltt}
frutas = ["manzanas", "peras", "fresas"]
\textcolor{blue}{for} x \textcolor{blue}{in} frutas:
  \textcolor{blue}{if} x == "peras":
    \textcolor{red}{break}
  \textcolor{blue}{print}(x) 
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} Como se puede observar en el ejemplo anterior, para realizar dicho \rverb|break|, es necesario introducir una proposición \emph{condicional} (\bverb|if|) que señale en qué \verb|item| se realizará el quiebre. Es importante tener presente que al imprimir un bucle que incorpore un \rverb|break|, se imprimirán todos los \verb|items| o elementos justo hasta aquel que preceda o anteceda el del quiebre\footnote{
En sentido estricto, eso sí, aquello dependerá si la orden de impresion se encuentra antes o después de la proposición condicional.}.
\par \hspace{5pt} Con la expresión \rverb|continue| es posible, a su vez, \emph{detener} la iteracion en ``curso'', para pasar a la siguente. Al igual que en el caso de \rverb|break|, es posible hacerlo para ambos tipos de bucles (\emph{for} y \emph{while}).
\begin{tcolorbox}
\begin{alltt}
frutas = ["manzanas", "peras", "fresas"]
\textcolor{blue}{for} x \textcolor{blue}{in} frutas:
  \textcolor{blue}{if} x == "peras":
    \textcolor{red}{continue}
  \textcolor{blue}{print}(x) 
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} En este caso, solo se imprimirán en el terminal las \verb|manzanas| y las \verb|fresas|, ya que al momento de iterar sobre las \verb|peras|, el código ordena pasar al próximo item antes de poder imprimirlo. 
\begin{tcolorbox}
\begin{alltt}
manzanas
fresas 
\end{alltt}        
\end{tcolorbox}
\vspace{0.5cm}

\item ¿Qué es una lista por comprensión en Python?
\par \hspace{5pt} Una manera de entender en qué consiste una lista de comprensión es decir que se trata, básicamente, de un tipo de sintaxis \emph{corta} para crear una nueva lista a partir de una lista \emph{ya} existente.
\par \hspace{5pt} Ahora bien, para aclarar un poco más esta caracterización general, quizás lo mejor sea ver un pequeño ejemplo. Definiremos una pequeña lista, \verb|frutas|, a partir de la cual crearemos una \verb|nueva_lista| en función de una determinada condición, a saber, que esté formada por términos que contengan al menos una vez la letra \verb|e|. Existen dos maneras para crear la \verb|nueva_lista|. Veamos cada una por separado.
\begin{tcolorbox}
\begin{alltt}
frutas = ["manzanas", "peras", "fresas", "kiwis"]
nueva_lista = [ ]
\end{alltt}        
\end{tcolorbox} 
\par \hspace{5pt} En caso de \emph{no} querer crear la \verb|nueva_lista| utilizando la sintáxis de la ``lista de comprensión'', tendríamos que emplear un bucle \verb|for| con una proposición condicional \verb|in| en su interior. Como se ve en el cuadro que presentamos a continuación, aquello implica escribir un código de tres líneas para llevar a cabo ese objetivo.
\begin{tcolorbox}
\begin{alltt}
\textcolor{blue}{for} x \textcolor{blue}{in} frutas:
  \textcolor{blue}{if} "e" \textcolor{blue}{in} x:
    nueva_lista.append(x)
\textcolor{blue}{print}(nueva_lista)
\end{alltt}        
\end{tcolorbox}
 Mucho más corto y, por ende, eficiente resulta la sintáxis de la ``lista de comprensión''. En \emph{una} sola línea es posible crear la \verb|nueva_lista| a partir de la anterior. Aquello puede que no sea muy relevante en un código pequeño, pero cuando se trata de uno grande, sí resulta importante.
\begin{tcolorbox}
\begin{alltt}
nueva_lista = [x \textcolor{blue}{for} x \textcolor{blue}{in} frutas \textcolor{blue}{if} "a" \textcolor{blue}{in} x]
\textcolor{blue}{print}(nueva_lista)
\end{alltt}        
\end{tcolorbox}
\vspace{0.5cm}
  
\item ¿Qué es un argumento en Python?
\par \hspace{5pt} Un \emph{argumento} es el nombre o término que aparece cuando ``llamamos'' a una función para ejecutarla. Es importante distinguirla del \emph{parámetro}, que corresponde más bien al término o nombre que aparece al inicio cuando ``definimos'' una función. Si bien ambos términos se utilizan de manera indistinta (un uso habitual pero, en sentido estricto, incorrecto), es necesario tener presente la distinción. Veámos un ejemplo para \emph{ver} con más claridad dicha diferencia y, de ese modo, entender mejor qué es un argumento.
\begin{tcolorbox}
\begin{alltt}
\textcolor{red}{def} \textcolor{blue}{add_num}(a, b):
    sum = a + b
    \textcolor{red}{print}(sum)
add_num(3, 4) 
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} Definimos (\rverb|def|) en primer lugar una función llamada \bverb|add_num| que, como se ve en la línea siguiente, simplemente suma dos términos (\verb|a|, \verb|b|). Dichos términos reciben el nombre de \emph{parámetros} cuando definimos la función. Ahora bien, cuando a dichos términos le asignamos un valor específico para querer ejecutar la función, \verb|3| y \verb|4| en nuestro ejemplo, ellos adoptan el nombre de \emph{argumento}. 
\vspace{0.5cm}

\item ¿Qué es una función Lambda en Python?
\par \hspace{5pt} Una función lambda es, lo que se llama, un función \emph{anónima}. ¿Qué significa eso? Básicamente, que \emph{no} tiene nombre. Ahora bien ¿qué consecuencia tiene eso? ¿Cuál es la utilidad o beneficio de eso? Que la puedo ejecutar simplemente invocando la variable que la define, ya que ella misma almacena la función en sí. Analicemos un par de ejemplos: una función \emph{normal} y luego una \emph{lambda}.
\begin{tcolorbox}
\begin{alltt}
\textcolor{red}{def} \textcolor{blue}{sum}(a):
    x = a + 10
    \textcolor{red}{print}(x)
sum(5)
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} En principio, si se quiere crear una función es necesario  definirla (\rverb|def|) asignándole un nombre (\bverb|sum|) y uno(s) parámetros (\verb|a|). Luego se requiere precisar la función propiamente tal en términos de una expresión formada por los parámtro(s) previamente definido(s), junto con las operacion(es) involucrada(s) ($\verb|a + 10|$) en ella. Dicha expresión la identificamos, a su vez, con una variable (\verb|x|) de manera de poder referenciarla posteriormente. Por último, en el caso que queramos ``ejecutar'' e ``imprimir'' dicho función, debemos invocar la orden \rverb|print|\verb|(x)| y luego ``llamar'' a la función, asignándole un valor al parametro o un argumento (\verb|5|). 
\begin{tcolorbox}
\begin{alltt}
x = \textcolor{blue}{lambda} a : a + 10
\textcolor{red}{print}(x(5))
\end{alltt}        
\end{tcolorbox}
\par \hspace{5pt} En el caso de la función lambda, ya que se trata de una función \emph{anónima} el proceso de definición y ejecución resulta mucho más corto y directo. Basta simplemente con identificar el o los parámetros de la función (\verb|a|) junto con la expresión que la caracteriza ($\verb|a + 10|$). Luego, al querer ejecutarla e imprimirla, debemos simplemente invocar la orden \rverb|print| haciendo referencia a la variable que la contiene (\verb|x|) junto con el argumento que queramos evaluar (\verb|5|).
\vspace{0.5cm}
  
\item ¿Qué es un paquete pip?
\par \hspace{5pt} Se llama \emph{pip} en python a un ``sistema de gestion de paquetes''. Su función principal es instalar y administrar los paquetes existentes de \emph{python}. Dichos paquetes son obtenidos del \href{https://pypi.org/}{Python Package Index}, aunque es posible descargarlos de otros índices tambien\footnote{El índice de paquetes de Python (PyPI) es un gran repositorio de \emph{software} para el lenguaje de programación python.}.
\par \hspace{5pt} Una de las grandes ventajas de \emph{pip} es la facilidad con la cual se pueden instalar y desinstalar los paquetes de software desde la ``línea de comandos'': basta con un simple comando como el siguiente para hacerlo:
\begin{tcolorbox}
\begin{alltt}
\textcolor{brown}{C:>} py -m pip install nombre-paquete 
\end{alltt}
\end{tcolorbox}
\par \hspace{5pt} Tal como está señalado en la \href{https://pip.pypa.io/en/stable/}{documentación} de \emph{pip}, para poder empezar a utilizarlo, es necesario tenerlo \emph{ya} instalado en nuestro sistema junto con \emph{python}. Podemos revisar si aquello es así a través de los siguientes comandos\footnote{Dependiendo del sistema operativo que tengamos en nuestro ordenador, sea Linux, MacOS o Windows, el comando empleado podrá variar un poco. En el siguiente cuadro  solo he colocado los comandos utilizados en Windows.}:  
 \begin{tcolorbox}
    \begin{alltt}
      \textcolor{brown}{C:>} py --version
      \emph{Python 3.N.N}
      \textcolor{brown}{C:>} py -m pip --version
      \emph{pip X.Y.Z from ... (python 3.N.N)}
    \end{alltt}        
  \end{tcolorbox}

  \par \hspace{5pt} Ahora bien, en el caso que \emph{pip} no se encuentre ya instalado en su sistema, existen dos maneras de hacerlo:

  \begin{itemize}
  \item
    \begin{alltt}
      ensurepip
    \end{alltt}
  \item
    \begin{alltt}
      get-pip.py
    \end{alltt} 
  \end{itemize}

  \par \hspace{5pt} En el caso de utilizar \verb|get-pip.py|, es necesario ejecutar los dos siguientes pasos:
  \begin{itemize}
  \item Descargar el \emph{script} desde \href{https://bootstrap.pypa.io/get-pip.py}{https://bootstrap.pypa.io/get-pip.py}.
  \item Abrir el terminal, luego \verb|cd| a la carpeta que contiene el archivo recién descargado \verb|get-pip.py|, y finalmente ejecutar:
    \begin{tcolorbox}
      \begin{alltt}
        \textcolor{brown}{C:>} py get-pip.py
      \end{alltt}        
    \end{tcolorbox}
  \end{itemize}

  \par \hspace{5pt} Una vez \emph{ya} instalado el programa \emph{pip} en nuestro sitema, podemos entonces comenzar a descargar los distintos paquetes que necesitemos mediante el comando inicial.

\end{enumerate}

\end{document}
